SQL : It queries from Tables
JPQL : It queries from Entities. (What ever JPQL queries we write it is internally converted into SQL by JPA implementation that is Hibernate)

Example:

SQL: Select * from COURSE;
JPQL: Select c from Course c;

#JPA and hibernate annotations
@Table
@Column 
@UpdateTimestamp - It tells when the row is updated last time and this is provided by hibernate.
@CreateTimestamp - It tells when the row created and this is provided by hibernate.

With the named query we can assigned the name with the query and reuse it again and again.
@NamedQuery
@NamedQueries

NativeQueries

Its always better to use JPQL but sometime we have to use Native queries as well like we have connect with a data base and some features are not supported by JPQL
In such situations we have no other options than to fire a Native queries.

Other situations when we have to go for a Native query like we have to do a mass update like we have to update all the rows in a specific table, in such situation
if we try to do it using JPQL the we need to get a single row and then update it again and again. We can not do mass update using JPA, so in such situations native queries is the solution.


@OneToOne
Any OneToOne relationship is always eager fetch by default.
And this might gives us a performance issues in our application. We can avoid this by using @OneToOne(fetch = FetchType.LAZY)
In Lazy fetching we will get those data what ever we needed at that point in time.

==================================================================================================================================================================================================================================================
**** Session, Session factory, Entity Manager, Persistence context and Transaction ****

When we talk about transaction everything should succeed or nothing should succeed. So within the transaction if any one operation fails entire transaction will be rolled back.
That is why we are using @Transactional annotation.

In the JPA as soon as you are defining Transaction using @Transactional annotation you would be defining something called Persistence Context.
So we can say a Persistence Context is a place where all the entities we are using in our application are being stored and its results which we get from the database.
So any changes or updated in the value of an entity will be also reflected in the Persistence context.

It should be note that only after a particular transaction is completed, the data will be sent to the database not before that. And during the execution of a transaction the change in data (create or update)
is tracked by Persistence context of that transaction.

They way we interact with the Persistence context is by using Entity Manager. So when ever we are calling any method on entity manager we are actually playing with Persistence context.
So Persistence Context is actually keeping the track of any changes in the data and it is started at the beginning of a transaction and kills as soon as transaction ended.


For Example: There are multiple create and update operations takes place in a method which is annotated with @Transactional annotation.
At this time all the operations are treated under a single transaction.

    @Test
	@Transactional
	public void uderstandPersistenceContextTest() {
		// Operation1: Retrieve Student
		Student student = entityManager.find(Student.class, 20001L);
		// Operation2: Retrieve PassPort
		Passport passport = student.getPassport();
		// Operation3: Update Passport
		passport.setNumber("EMJPS654");
		// Operation4: Update Student
		student.setName("Rohit Sharma");
		
		
	}

Suppose if we remove @Transactional annotation then each operation (method call on entity manager's object) acts as if its own transaction. So as soon as operation ended transaction ended and its Persistence context is closed.
If we try to perform another operation we will get an exception like==> Could not initialize proxy - no session (In Hibernate terminology Session = Persistence Context in JPA terminology). Because Persistence context is closed by then.

Note 1: The Actual insert or update happens after the completion of all transactions. If you want to push your changes in the database in between an ongoing transaction then you can use flush() for example:

         @Autowired
          EntiryManager em;

         @Transactional
         public void someMethodWithChange{
            
                 //Create Objects
                 em.persist(user1);
                 em.persist(user2);
                 em.flush();  // here we are saving user1 and user2 in data base even before completion of transaction.
                 //Change user1;
                 //Change user2;
                 
            }   // At this line transaction is completed and all changes saved to the database 


Note 2: In JPA we use Entity Manager to talk to the Persistence context 

Persistence Context also gives access to the data base.
While in Hibernate we use Session and Session Factory.

====================================================================================================================================================================================================================================================
** Bidirectional one-to-one relationship **
In the bidirectional one-to-one relation the owning side entity (example: Student) define as following:

@Entity
public class Student {

	@Id
	@GeneratedValue
	private Long id;
	private String name;
	
	@OneToOne(fetch = FetchType.LAZY)
	private Passport passport;
	
	}

there is no mapped by field.

But non-owning side entity (example: Passport) we must have to mention the field name which is there at owning side in mapped by attribute as following:

@Entity
public class Passport {

	@Id
	@GeneratedValue
	private Long id;
	
	@Column(nullable = false)
	private String number;
	
	@OneToOne(fetch = FetchType.LAZY, mappedBy = "passport")
	private Student student;
	
}

====================================================================================================================================================================================================================================================
** Why to use @Transactional in Unit test ? **

First of all when ever we have to make any change in the database we have to use transaction and that is provided by @Transational annotation.
-- If we put @Trasactional at method level then the operation performed inside the entire method comes in the boundary of transaction.
-- If we put @Trasactional at class level entire class comes in the boundary of transaction.

** Do Read only methods need transaction ? **
Suppose we have two entities --> User , Comments 
And we are performing following read only method with our using @Transactional:

//@Transactional
List<Comments> someReadOnlyMethod(){ 
      
      User user = em.find(User.class, 1L);  // Since we haven't provide @Transactional, so entity manager makes use of default transaction and as soon as this line end transaction ends.
      
      List <Comments> comments = user.getComments(); // And since at this line we are not making the use of entity manager so there is nothing which provides transaction and since we need to fire a query in the data base to retrieve comments and we need connection to the data base and it require transaction, so this line will give an error.
      
      return comments;
}

** Why do we use @DirtiesContext ? **

Lets say we have couple of Unit tests, and some of the unit tests might update the data which is there is Data base to full fill their requirements.
This might affects some other units tests, and they got failed. So what @DirtiesContext does, it ensures all the changes which are made in the data base are rolled back.
And this will make sure there are no dependencies in the order of execution of unit tests.


** What is the difference between defining @Transactional on class vs method ? **

Case1
@Transactional
public class UserServiceImpl implements UserService {

    ...................
    public void method1(){
        try{
            method2();
        }catch(Exception e){

        }
    }
    public void method2(){

    }
}
Case2
public class UserServiceImpl implements UserService {

    ...................
    public void method1(){
        try{
            method2();
        }catch(Exception e){

        }
    }
    @Transactional
    public void method2(){

    }
}

In case 1 @Transactional is applied to every public individual method. Private and Protected methods are Ignored by Spring.

In case 2 @Transactional is only applied to method2(), not on method1()

Case 1: - Invoking method1() -> a transaction is started. When method1() calls method2() no new transaction is started, because there is already one

Case 2: - Invoking method1() -> no transaction is started. When method1() calls method2() NO new transaction is started. This is because @Transactional does not work when calling a method from within the same class. It would work if you would call method2() from another class.

============================================================================================================================================================================================================================================================================================================

By default the fetch strategy of a relationship at oneToMany side is lazy,
So by default below code is fetching lazy way:

@OneToMany(mappedBy = "course")
List<Review> reviews = new ArrayList<>();

We can make this as eager fetching by making below changes:

@OneToMany(mappedBy = "course", fetch = FetchType.EAGER)
List<Review> reviews = new ArrayList<>();
	
But on the other hand, at ManyToOne side of the relationship by default fetching strategy is always eager.
So by default below code is fetching eager way

@ManyToOne
private Course course;

We can make this as lazy fetching by making below changes:
@ManyToOne(fetch = FetchType.LAZY)
	private Course course;
	
	
So we can remember this like :
**ToOne : Default is Eager fetching
**ToMany :Default is Lazy fetching

======================================================================================================================================================================================================================================
** ManyToMay relationship between Student and Course **

In ManyToMany relationship it doesn't matter which side is the owning side, but we must have to define an owning side.

@JoinTable is used to create a join table. We can define the attribute name= "Name of the Join table" and JoinCoumn (Student_Id) 
and InverseJoinColumn (Course_Id) we can define it a following:

    @ManyToMany
	@JoinTable(name = "STUDENT_COURSE", joinColumns = @JoinColumn(name = "STUDENT_ID"), 
	           inverseJoinColumns = @JoinColumn(name = "COURSE_ID"))
	private List<Course> courses = new ArrayList<>();


** Difference between JPA & hibernate ? **

JPA is a specification/Interface
Hibernate is one of JPA implementations
When we use JPA, we use the annotation and interfaces from javax.persistence package, without using the hibernate import packages.

We recommend using JPA annotations as we are not tied to Hibernate as implementation. Later (I know - <1% Chance), we can use another JPA implementation.

If you are using JPA annotations, you would be using JPA + Hibernate.

If you are directly using hibernate annotations, you are only using Hibernate.

