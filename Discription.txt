SQL : It queries from Tables
JPQL : It queries from Entities. (What ever JPQL queries we write it is internally converted into SQL by JPA implementation that is Hibernate)

Example:

SQL: Select * from COURSE;
JPQL: Select c from Course c;

#JPA and hibernate annotations
@Table
@Column 
@UpdateTimestamp - It tells when the row is updated last time and this is provided by hibernate.
@CreateTimestamp - It tells when the row created and this is provided by hibernate.

With the named query we can assigned the name with the query and reuse it again and again.
@NamedQuery
@NamedQueries

NativeQueries

Its always better to use JPQL but sometime we have to use Native queries as well like we have connect with a data base and some features are not supported by JPQL
In such situations we have no other options than to fire a Native queries.

Other situations when we have to go for a Native query like we have to do a mass update like we have to update all the rows in a specific table, in such situation
if we try to do it using JPQL the we need to get a single row and then update it again and again. We can not do mass update using JPA, so in such situations native queries is the solution.


@OneToOne
Any OneToOne relationship is always eager fetch by default.
And this might gives us a performance issues in our application. We can avoid this by using @OneToOne(fetch = FetchType.LAZY)
In Lazy fetching we will get those data what ever we needed at that point in time.

==================================================================================================================================================================================================================================================
**** Session, Session factory, Entity Manager, Persistence context and Transaction ****

When we talk about transaction everything should succeed or nothing should succeed. So within the transaction if any one operation fails entire transaction will be rolled back.
That is why we are using @Transactional annotation.

In the JPA as soon as you are defining Transaction using @Transactional annotation you would be defining something called Persistence Context.
So we can say a Persistence Context is a place where all the entities we are using in our application are being stored and its results which we get from the database.
So any changes or updated in the value of an entity will be also reflected in the Persistence context.

It should be note that only after a particular transaction is completed, the data will be sent to the database not before that. And during the execution of a transaction the change in data (create or update)
is tracked by Persistence context of that transaction.

They way we interact with the Persistence context is by using Entity Manager. So when ever we are calling any method on entity manager we are actually playing with Persistence context.
So Persistence Context is actually keeping the track of any changes in the data and it is started at the beginning of a transaction and kills as soon as transaction ended.


For Example: There are multiple create and update operations takes place in a method which is annotated with @Transactional annotation.
At this time all the operations are treated under a single transaction.

    @Test
	@Transactional
	public void uderstandPersistenceContextTest() {
		// Operation1: Retrieve Student
		Student student = entityManager.find(Student.class, 20001L);
		// Operation2: Retrieve PassPort
		Passport passport = student.getPassport();
		// Operation3: Update Passport
		passport.setNumber("EMJPS654");
		// Operation4: Update Student
		student.setName("Rohit Sharma");
		
		
	}

Suppose if we remove @Transactional annotation then each operation (method call on entity manager's object) acts as if its own transaction. So as soon as operation ended transaction ended and its Persistence context is closed.
If we try to perform another operation we will get an exception like==> Could not initialize proxy - no session (In Hibernate terminology Session = Persistence Context in JPA terminology). Because Persistence context is closed by then.

Note 1: The Actual insert or update happens after the completion of all transactions. If you want to push your changes in the database in between an ongoing transaction then you can use flush() for example:

         @Autowired
          EntiryManager em;

         @Transactional
         public void someMethodWithChange{
            
                 //Create Objects
                 em.persist(user1);
                 em.persist(user2);
                 em.flush();  // here we are saving user1 and user2 in data base even before completion of transaction.
                 //Change user1;
                 //Change user2;
                 
            }   // At this line transaction is completed and all changes saved to the database 


Note 2: In JPA we use Entity Manager to talk to the Persistence context 

Persistence Context also gives access to the data base.
While in Hibernate we use Session and Session Factory.

====================================================================================================================================================================================================================================================
** Bidirectional one-to-one relationship **
In the bidirectional one-to-one relation the owning side entity (example: Student) define as following:

@Entity
public class Student {

	@Id
	@GeneratedValue
	private Long id;
	private String name;
	
	@OneToOne(fetch = FetchType.LAZY)
	private Passport passport;
	
	}

there is no mapped by field.

But non-owning side entity (example: Passport) we must have to mention the field name which is there at owning side in mapped by attribute as following:

@Entity
public class Passport {

	@Id
	@GeneratedValue
	private Long id;
	
	@Column(nullable = false)
	private String number;
	
	@OneToOne(fetch = FetchType.LAZY, mappedBy = "passport")
	private Student student;
	
}

====================================================================================================================================================================================================================================================
** Why to use @Transactional in Unit test ? **

First of all when ever we have to make any change in the database we have to use transaction and that is provided by @Transational annotation.
-- If we put @Trasactional at method level then the operation performed inside the entire method comes in the boundary of transaction.
-- If we put @Trasactional at class level entire class comes in the boundary of transaction.

** Do Read only methods need transaction ? **
Suppose we have two entities --> User , Comments 
And we are performing following read only method with our using @Transactional:

//@Transactional
List<Comments> someReadOnlyMethod(){ 
      
      User user = em.find(User.class, 1L);  // Since we haven't provide @Transactional, so entity manager makes use of default transaction and as soon as this line end transaction ends.
      
      List <Comments> comments = user.getComments(); // And since at this line we are not making the use of entity manager so there is nothing which provides transaction and since we need to fire a query in the data base to retrieve comments and we need connection to the data base and it require transaction, so this line will give an error.
      
      return comments;
}

** Why do we use @DirtiesContext ? **

Lets say we have couple of Unit tests, and some of the unit tests might update the data which is there is Data base to full fill their requirements.
This might affects some other units tests, and they got failed. So what @DirtiesContext does, it ensures all the changes which are made in the data base are rolled back.
And this will make sure there are no dependencies in the order of execution of unit tests.


** What is the difference between defining @Transactional on class vs method ? **

Case1
@Transactional
public class UserServiceImpl implements UserService {

    ...................
    public void method1(){
        try{
            method2();
        }catch(Exception e){

        }
    }
    public void method2(){

    }
}
Case2
public class UserServiceImpl implements UserService {

    ...................
    public void method1(){
        try{
            method2();
        }catch(Exception e){

        }
    }
    @Transactional
    public void method2(){

    }
}

In case 1 @Transactional is applied to every public individual method. Private and Protected methods are Ignored by Spring.

In case 2 @Transactional is only applied to method2(), not on method1()

Case 1: - Invoking method1() -> a transaction is started. When method1() calls method2() no new transaction is started, because there is already one

Case 2: - Invoking method1() -> no transaction is started. When method1() calls method2() NO new transaction is started. This is because @Transactional does not work when calling a method from within the same class. It would work if you would call method2() from another class.

============================================================================================================================================================================================================================================================================================================

By default the fetch strategy of a relationship at oneToMany side is lazy,
So by default below code is fetching lazy way:

@OneToMany(mappedBy = "course")
List<Review> reviews = new ArrayList<>();

We can make this as eager fetching by making below changes:

@OneToMany(mappedBy = "course", fetch = FetchType.EAGER)
List<Review> reviews = new ArrayList<>();
	
But on the other hand, at ManyToOne side of the relationship by default fetching strategy is always eager.
So by default below code is fetching eager way

@ManyToOne
private Course course;

We can make this as lazy fetching by making below changes:
@ManyToOne(fetch = FetchType.LAZY)
	private Course course;
	
	
So we can remember this like :
**ToOne : Default is Eager fetching
**ToMany :Default is Lazy fetching

======================================================================================================================================================================================================================================
** ManyToMay relationship between Student and Course **

In ManyToMany relationship it doesn't matter which side is the owning side, but we must have to define an owning side.

@JoinTable is used to create a join table. We can define the attribute name= "Name of the Join table" and JoinCoumn (Student_Id) 
and InverseJoinColumn (Course_Id) we can define it a following:

    @ManyToMany
	@JoinTable(name = "STUDENT_COURSE", joinColumns = @JoinColumn(name = "STUDENT_ID"), 
	           inverseJoinColumns = @JoinColumn(name = "COURSE_ID"))
	private List<Course> courses = new ArrayList<>();


** Difference between JPA & hibernate ? **

JPA is a specification/Interface
Hibernate is one of JPA implementations
When we use JPA, we use the annotation and interfaces from javax.persistence package, without using the hibernate import packages.

We recommend using JPA annotations as we are not tied to Hibernate as implementation. Later (I know - <1% Chance), we can use another JPA implementation.

If you are using JPA annotations, you would be using JPA + Hibernate.

If you are directly using hibernate annotations, you are only using Hibernate.


=====================================================================================================================================================================================================================================================
** Inheritance hierarchies with JPA and hibernate **

1. Single Table strategy:
---------------------------

If we don't specify any inheritance strategy, then by default strategy will be Single table.
In this all the subclasses data mapped to a single Table.

Advantage with Single table hierarchy :
High Performance, because we would get everything from a single table. And we donn't have to do any joins and all.

Disadvantage with Single table hierarchy :
We would have a lot of nullable columns.

Note: We can specify Discriminator Column as following:
      @DiscriminatorColumn(name = "EmployeeType")
      
Example:

@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "EmployeeType")
public abstract class Employee {
      // ....
}
      
      
2. Table Per class Strategy:
-------------------------

As per the definition Table per class means Table per concrete entity class.
In this Each concrete subclass is provided with a Table.
 
And if you see the console they are actually retrieve using union:

 select
        employee0_.id as id1_1_,
        employee0_.name as name2_1_,
        employee0_.salary as salary1_2_,
        employee0_.hourly_wage as hourly_w1_3_,
        employee0_.clazz_ as clazz_ 
    from
        ( select
            id,
            name,
            salary,
            null as hourly_wage,
            1 as clazz_ 
        from
            full_time_employee 
        union
        all select
            id,
            name,
            null as salary,
            hourly_wage,
            2 as clazz_ 
        from
            part_time_employee 
    ) employee0_

Disadvantage of using Table per class Strategy : Common columns are repeated in multiple tables.

Example:

@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Employee { }



One of the advantage of using JPA is that how we insert Employee and how we retrieve Employee is not dependent on which Inheritance strategy we are using.


3. Joined Strategy:
-----------------

In this there would be a separate tables for parent class and subclass. And if we want to retrieve all the details there will be a join performed in between them. 

As per the Documentation:
 /** 
     * A strategy in which fields that are specific to a 
     * subclass are mapped to a separate table than the fields 
     * that are common to the parent class, and a join is 
     * performed to instantiate the subclass.
     */


Disadvantage of Joined strategy: Performance wise it is not that much effective. Because in the background it will perform so many join operations in a multiple tables.

Example:

@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class Employee {


4. using @MappedSuperclass
------------------------------

If we are putting this annotation in our Employee class, so it can not be an entity.
Because if we are using this on Employee class then it will no longer be an Entity and there will be no Table corresponding to Employee.
Here Employee is used like a template to store common attribute used in subclasses. Actual query to retrieve data is happening in subclass it self.
There is No inheritance relationship here.


Here two separate queries are executing to retrieve two different subclass data. And here there is nothing to do with Employee.

    select
        parttimeem0_.id as id1_2_,
        parttimeem0_.name as name2_2_,
        parttimeem0_.hourly_wage as hourly_w3_2_ 
    from
        part_time_employee parttimeem0_
        
        
    select
        fulltimeem0_.id as id1_1_,
        fulltimeem0_.name as name2_1_,
        fulltimeem0_.salary as salary3_1_ 
    from
        full_time_employee fulltimeem0_
        
Example:
 
@MappedSuperclass
public abstract class Employee {  }
        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

** When to Use What? **

If we are more concern about Data integrity then we should use Joined Strategy. Because in this we can made all columns as non nullable and there is no chance to insert a bad data in any table.
If We are more concern about the performance the Single table Strategy will be the best option.


===========================================================================================================================================================================================================================================================================================================================================================================

   // Join with JPQL
	//Join ==> Select c , s from Course c JOIN Student s;
	
	//Left Join ==> Select c , s from Course c  LEFT JOIN Student s;
	(There might be courses without students so with LEFT JOIN it will return courses which do not have students)
	
	// Cross Join ==> Select c, s from Course c, Student s;
	(It just take every course and mixes them with every student which is present in there.
	 For example if there are 3 students and 4 courses the it will return 3*4 = 12 rows back)
	





